## 비관적 잠금 DB 락 -> Redis 분산 Lock 전환 성능 분석 문서

## [1] Redis Simple Lock 동시성 제어 성능 분석

## 1-1. 개요

본 문서는 Redis Simple Lock(Spin Lock) 방식을 사용한 쿠폰 발급 동시성 제어의 성능을 분석합니다.

## 1-2. 테스트 환경

- **테스트 일시**: 2025년 11월 26일
- **Redis 버전**: 8.4.0 (Testcontainers)
- **MySQL 버전**: 8.0 (Testcontainers)
- **테스트 프레임워크**: Jest
- **Node.js 환경**: NestJS

_테스트 실행 명령어_

```bash
npx jest test/integration/redis/issue-coupon.use-case.integration.spec.ts --verbose --runInBand
```

## 1-3. Simple Lock 구현 방식

### Application 레이어의 락 키 전달

```typescript
const lockKey = `coupon:issue:${cmd.couponId}`;
return await this.redisLockService.withLock(lockKey, async () => {
  // 쿠폰 발급 로직
});
```

### 락 획득 (acquireLock)

```typescript
async acquireLock(key: string, ttlMs: number = 5000): Promise<boolean> {
  const result = await this.client.set(key, '1', {
    PX: ttlMs,  // 만료 시간 (밀리초)
    NX: true,   // 키가 없을 때만 설정
  });
  return result === 'OK';
}
```

### Spin Lock 패턴 (withLock)

```typescript
async withLock<T>(key: string, fn: () => Promise<T>, ttl: number = 5000): Promise<T> {
  const lockKey = `lock:${key}`;

  // 최대 100회 재시도 (Spin Lock)
  for (let i = 0; i < 100; i++) {
    const acquired = await this.acquireLock(lockKey, ttl);
    if (acquired) {
      try {
        return await fn();
      } finally {
        await this.releaseLock(lockKey);
      }
    }
    // 0.02초 대기
    await new Promise((resolve) => setTimeout(resolve, 200));
  }

  throw new Error(`Failed to acquire lock for key: ${key}`);
}
```

---

## 테스트 결과

### 전체 테스트 실행 시간

| 항목                    | 시간         |
| ----------------------- | ------------ |
| **전체 테스트 스위트**  | **39.641초** |
| 컨테이너 시작 및 초기화 | ~10초        |
| 실제 테스트 실행        | ~29초        |

### 개별 테스트 케이스 성능

| 테스트 케이스         | 동시 요청 수 | 쿠폰 수량 | 실행 시간    | 결과                    |
| --------------------- | ------------ | --------- | ------------ | ----------------------- |
| 다중 사용자 동시 발급 | 20명         | 10개      | **4,156ms**  | ✅ 10명 성공, 10명 실패 |
| 중복 발급 방지        | 10회 (1명)   | 100개     | **1,983ms**  | ✅ 1번 성공, 9번 실패   |
| 마지막 1개 경쟁       | 10명         | 1개       | **1,966ms**  | ✅ 1명 성공, 9명 실패   |
| 다른 쿠폰 병렬 발급   | 2명          | 각 10개   | **87ms**     | ✅ 2명 모두 성공        |
| 대규모 동시성 테스트  | 100명        | 50개      | **21,050ms** | ✅ 50명 성공, 50명 실패 |

## 성능 분석

### 1. 처리량 (Throughput)

| 시나리오        | 요청 수 | 실행 시간 | 초당 처리량    |
| --------------- | ------- | --------- | -------------- |
| 20명 동시 요청  | 20      | 4.156s    | **4.81 req/s** |
| 100명 동시 요청 | 100     | 21.05s    | **4.75 req/s** |

### 2. 평균 요청 처리 시간

| 시나리오          | 성공 요청 | 총 시간 | 평균 처리 시간/요청 |
| ----------------- | --------- | ------- | ------------------- |
| 20명 → 10명 성공  | 10        | 4.156s  | **~415ms**          |
| 100명 → 50명 성공 | 50        | 21.05s  | **~421ms**          |

### 3. Spin Lock 재시도 오버헤드

- **재시도 간격**: 200ms
- **최대 재시도 횟수**: 100회
- **최대 대기 시간**: 100 × 200ms = **20초**

대규모 테스트(100명 동시 요청)에서 21초가 소요된 이유:

- 50명이 순차적으로 락을 획득
- 각 요청당 DB 트랜잭션 처리 시간 + 락 대기 시간

## Simple Lock 방식의 장단점

### 장점

1. **구현 단순성**
   - Redis의 `SET NX PX` 명령어만으로 구현 가능
   - 추가 라이브러리 불필요

2. **정합성 보장**
   - 모든 테스트에서 Over-issue 없이 정확한 수량 관리
   - 중복 발급 완벽 방지

3. **다른 키에 대한 병렬 처리**
   - 서로 다른 쿠폰(락 키)은 동시 처리 가능 (87ms)

### 단점

1. **Spin Lock 오버헤드**
   - 락 대기 중 주기적인 Redis 요청 발생
   - CPU 및 네트워크 리소스 소비

2. **처리량 제한**
   - 동일 락 키에 대해 순차 처리 강제
   - 초당 ~5개 요청 처리 (단일 락 키 기준)

3. **대기 시간 증가**
   - 동시 요청이 많을수록 후순위 요청의 대기 시간 증가
   - 100명 동시 요청 시 최대 20초 대기 가능

4. **락 해제 전 장애 시 문제**
   - TTL 만료까지 다른 요청 대기 필요
   - 현재 TTL: 5초

---

## [2] 비관락(Pessimistic Lock) vs 분산락(Redis Distributed Lock) 성능 비교

### 테스트 일시

- **테스트 일시**: 2025년 11월 26일
- **테스트 환경**: Testcontainers (MySQL 8.0, Redis 8.4.0)

### 비교 대상

| 방식                                | 구현                          | 특징                            |
| ----------------------------------- | ----------------------------- | ------------------------------- |
| **비관락 (Pessimistic Lock)**       | DB `SELECT ... FOR UPDATE`    | 트랜잭션 레벨에서 행 잠금       |
| **분산락 (Redis Distributed Lock)** | Redis `SET NX PX` + Spin Lock | 애플리케이션 레벨에서 분산 잠금 |

### 성능 테스트 결과

#### 비관락 (DB FOR UPDATE)

| 테스트 케이스         | 동시 요청 수 | 쿠폰 수량 | 실행 시간 | 처리량           | 결과                    |
| --------------------- | ------------ | --------- | --------- | ---------------- | ----------------------- |
| 다중 사용자 동시 발급 | 20명         | 10개      | **117ms** | **170.94 req/s** | ✅ 10명 성공, 10명 실패 |
| 중복 발급 방지        | 10회 (1명)   | 100개     | **23ms**  | **434.78 req/s** | ✅ 1번 성공, 9번 실패   |
| 마지막 1개 경쟁       | 10명         | 1개       | **23ms**  | **434.78 req/s** | ✅ 1명 성공, 9명 실패   |
| 다른 쿠폰 병렬 발급   | 2명          | 각 10개   | **6ms**   | **333.33 req/s** | ✅ 2명 모두 성공        |
| 대규모 동시성 테스트  | 100명        | 50개      | **318ms** | **314.47 req/s** | ✅ 50명 성공, 50명 실패 |

#### 분산락 (Redis Simple Lock + Spin Lock)

| 테스트 케이스         | 동시 요청 수 | 쿠폰 수량 | 실행 시간 | 처리량           | 결과                    |
| --------------------- | ------------ | --------- | --------- | ---------------- | ----------------------- |
| 다중 사용자 동시 발급 | 20명         | 10개      | **426ms** | **46.95 req/s**  | ✅ 10명 성공, 10명 실패 |
| 중복 발급 방지        | 10회 (1명)   | 100개     | **200ms** | **50.00 req/s**  | ✅ 1번 성공, 9번 실패   |
| 마지막 1개 경쟁       | 10명         | 1개       | **195ms** | **51.28 req/s**  | ✅ 1명 성공, 9명 실패   |
| 다른 쿠폰 병렬 발급   | 2명          | 각 10개   | **76ms**  | **26.32 req/s**  | ✅ 2명 모두 성공        |
| 대규모 동시성 테스트  | 100명        | 50개      | **838ms** | **119.33 req/s** | ✅ 50명 성공, 50명 실패 |

### 성능 비교 분석

#### 1. 처리량 비교 (단일 락 키 기준)

| 시나리오        | 비관락       | 분산락       | 성능 차이                |
| --------------- | ------------ | ------------ | ------------------------ |
| 20명 동시 요청  | 170.94 req/s | 46.95 req/s  | **비관락이 ~3.6배 빠름** |
| 100명 동시 요청 | 314.47 req/s | 119.33 req/s | **비관락이 ~2.6배 빠름** |

#### 2. 응답 시간 비교

| 시나리오          | 비관락 | 분산락 | 차이                  |
| ----------------- | ------ | ------ | --------------------- |
| 20명 동시 요청    | 117ms  | 426ms  | 분산락이 ~3.6배 느림  |
| 100명 동시 요청   | 318ms  | 838ms  | 분산락이 ~2.6배 느림  |
| 다른 키 병렬 처리 | 6ms    | 76ms   | 분산락이 ~12.7배 느림 |

#### 3. 성능 차이 원인 분석

**비관락이 더 빠른 이유:**

1. **DB 내부 최적화**
   - MySQL InnoDB의 행 잠금은 내부적으로 최적화되어 있음
   - 락 대기열이 DB 엔진 레벨에서 효율적으로 관리됨
   - 네트워크 왕복 없이 DB 내부에서 락 처리

2. **동기식 처리**
   - 트랜잭션 내에서 락 획득과 해제가 자동 관리
   - 별도의 재시도 로직 불필요

**분산락이 느린 이유:**

1. **Spin Lock 오버헤드**
   - 락 실패 시 20ms 간격으로 재시도 (최대 100회)
   - 각 재시도마다 Redis 네트워크 왕복 발생
   - 동시 요청이 많을수록 대기 시간 증가

2. **네트워크 레이턴시**
   - Redis 서버로의 추가 네트워크 왕복 필요
