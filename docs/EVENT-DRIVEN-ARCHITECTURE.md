# 📊 이벤트 기반 아키텍처 설계 보고서

> 이 문서는 결제 처리 유즈케이스에 이벤트 기반 아키텍처를 적용한 사례를 다룹니다.
> 결제 처리 유즈케이스의 상세 이벤트 구성 및 흐름도는 [EVENT-FLOW-DIAGRAM.md](./EVENT-FLOW-DIAGRAM.md) 문서를 참고하세요.
> 외부플랫폼 데이터 전송을 Kafka로 부하 분산하는 설계는 [KAFKA_EXTERNAL_PLATFORM_DESIGN.md](./KAFKA_EXTERNAL_PLATFORM_DESIGN.md) 문서를 참고하세요.

> 참고: 현재 구현은 코레오그래피 기반 이벤트 체인으로 전환되어 있습니다.
> 최신 설계/흐름은 [CHOREOGRAPHY-ARCHITECTURE.md](./CHOREOGRAPHY-ARCHITECTURE.md), [CHOREOGRAPHY-FLOW-DIAGRAM.md](./CHOREOGRAPHY-FLOW-DIAGRAM.md)를 참고하세요.

---

## 📑 목차

1. [기존 아키텍처 분석](#1-기존-아키텍처-분석)
2. [이벤트 기반 설계 적용](#2-이벤트-기반-설계-적용)
3. [트랜잭션 분리 전략](#3-트랜잭션-분리-전략)
4. [배포 단위 도메인 분리](#4-배포-단위-도메인-분리)
5. [핵심 로직과 부가 로직 분리](#5-핵심-로직과-부가-로직-분리)
6. [결론](#6-결론)

---

## 1. 기존 아키텍처 분석

### 1.1 기존 구조 (AS-IS)

기존 결제 처리 로직은 이미 트랜잭션을 분리하고 보상 트랜잭션을 적용한 구조였습니다:

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      기존 트랜잭션 분리 구조 (AS-IS)                          │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                     ProcessPaymentUseCase                               │ │
│  │  ┌─────────────────────────────────────────────────────────────────┐   │ │
│  │  │ Transaction 1: (주문조회 / 재고차감 / 쿠폰사용)                  │   │ │
│  │  │ • ProductService.confirmPaymentStock()                          │   │ │
│  │  │ • CouponService.useCoupon()                                     │   │ │
│  │  └─────────────────────────────────────────────────────────────────┘   │ │
│  │                              │                                          │ │
│  │                              ▼                                          │ │
│  │  ┌─────────────────────────────────────────────────────────────────┐   │ │
│  │  │ Transaction 2: 잔액 차감                                         │   │ │
│  │  │ • UserService.deductBalance()                                   │   │ │
│  │  └─────────────────────────────────────────────────────────────────┘   │ │
│  │                              │                                          │ │
│  │                              ▼                                          │ │
│  │  ┌─────────────────────────────────────────────────────────────────┐   │ │
│  │  │ 외부 처리: 플랫폼 전송                                           │   │ │
│  │  │ • DataPlatformService.send()                                    │   │ │
│  │  └─────────────────────────────────────────────────────────────────┘   │ │
│  │                                                                          │ │
│  │  catch (error) {                                                         │ │
│  │    // 트랜잭션 커밋 상태 체크 후 개별 보상 트랜잭션 수행               │ │
│  │    if (stockCommitted) await rollbackStock();                           │ │
│  │    if (couponUsed) await rollbackCoupon();                              │ │
│  │  }                                                                       │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
│                                                                               │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 기존 구조의 한계

| 문제                   | 영향                                               | 심각도  |
| ---------------------- | -------------------------------------------------- | ------- |
| **강한 결합도**        | UseCase가 Product, Coupon, User 서비스에 직접 의존 | 🔴 높음 |
| **보상 트랜잭션 집중** | catch 블록에서 커밋 상태 체크 및 롤백 로직 복잡    | 🟡 중간 |
| **확장성 부족**        | 새 기능(알림, 분석 등) 추가 시 UseCase 수정 필수   | 🟡 중간 |
| **코드 관심사 혼재**   | 핵심 로직과 부가 로직이 혼재되어 유지보수 어려움   | 🟢 낮음 |

---

## 2. 이벤트 기반 설계 적용

### 2.1 개선된 아키텍처 (TO-BE)

```
┌──────────────────────────────────────────────────────────────────────────────┐
│              이벤트 기반 완전 분리 구조 (TO-BE) - Zero Coupling               │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │   ProcessPaymentUseCase (오직 EventEmitter와 OrderService만 의존)       │ │
│  │   ─────────────────────────────────────────────────────────────────────  │ │
│  │   • ProductService ❌ 의존 없음                                         │ │
│  │   • CouponService ❌ 의존 없음                                          │ │
│  │   • UserService ❌ 의존 없음                                            │ │
│  │   • DataPlatformService ❌ 의존 없음                                    │ │
│  └───────────────────────────────┬─────────────────────────────────────────┘ │
│                                  │                                           │
│                          이벤트 발행만 수행                                  │
│                                  │                                           │
│          ┌───────────────────────┼───────────────────────────┐              │
│          │                       │                           │              │
│          ▼                       ▼                           ▼              │
│  ┌───────────────┐       ┌───────────────┐           ┌───────────────┐     │
│  │    order.     │       │    order.     │           │    order.     │     │
│  │  processing   │       │   payment     │           │  processed    │     │
│  └───────┬───────┘       └───────┬───────┘           └───────┬───────┘     │
│          │                       │                           │              │
│    ┌─────┴─────┐                 │                     ┌─────┴─────┐       │
│    │           │                 │                     │           │       │
│    ▼           ▼                 ▼                     ▼           ▼       │
│ ┌──────┐   ┌──────┐         ┌──────┐             ┌──────┐   ┌──────┐     │
│ │Product│   │Coupon│         │ User │             │Order │   │Product│     │
│ │Module │   │Module│         │Module│             │Module│   │Module │     │
│ │재고   │   │쿠폰  │         │잔액  │             │데이터│   │판매   │     │
│ │확정   │   │사용  │         │차감  │             │플랫폼│   │랭킹   │     │
│ └──────┘   └──────┘         └──────┘             └──────┘   └──────┘     │
│     │           │                │                                         │
│     │           │                │                                         │
│     ▼           ▼                ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    각 도메인이 자체 보상 트랜잭션 관리                │   │
│  │   실패 시 order.processing.fail / order.payment.fail 이벤트 발행    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                               │
│  ✅ 핵심: UseCase는 이벤트만 발행, 각 도메인이 자신의 트랜잭션을 독립 관리  │
│  ✅ 트랜잭션: 재고/쿠폰/잔액 모두 개별 트랜잭션 (묶여있지 않음)             │
│  ✅ 보상: 각 리스너가 실패 이벤트 발행 → 다른 리스너들이 롤백 수행          │
│                                                                               │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 핵심 설계 원칙: 완전한 관심사 분리

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    완전한 관심사 분리 (100% Decoupling)                       │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ 🎯 ProcessPaymentUseCase의 역할 (오케스트레이터)                        │ │
│  │ ─────────────────────────────────────────────────────────────────────── │ │
│  │                                                                          │ │
│  │ constructor(                                                             │ │
│  │   orderService: OrderDomainService,  // ✅ 자신의 도메인만 의존         │ │
│  │   eventEmitter: EventEmitter2,       // ✅ 이벤트 발행만 담당           │ │
│  │   redisLockService: RedisLockService // ✅ 동시성 제어                  │ │
│  │ )                                                                        │ │
│  │                                                                          │ │
│  │ // ❌ ProductService 의존 없음                                          │ │
│  │ // ❌ CouponService 의존 없음                                           │ │
│  │ // ❌ UserService 의존 없음                                             │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ 🔧 각 도메인 리스너의 역할 (자율적 처리)                                │ │
│  │ ─────────────────────────────────────────────────────────────────────── │ │
│  │                                                                          │ │
│  │ Product: OnOrderProcessingListener                                       │ │
│  │   → 자체 트랜잭션으로 재고 확정 차감                                    │ │
│  │   → 실패 시 order.processing.fail 이벤트 발행                           │ │
│  │                                                                          │ │
│  │ Coupon: OnOrderProcessingListener                                        │ │
│  │   → 자체 트랜잭션으로 쿠폰 사용 처리 (Redis + DB)                       │ │
│  │   → 실패 시 order.processing.fail 이벤트 발행                           │ │
│  │                                                                          │ │
│  │ User: OnOrderPaymentListener                                             │ │
│  │   → 자체 트랜잭션으로 잔액 차감 (낙관적 잠금)                           │ │
│  │   → 실패 시 order.payment.fail 이벤트 발행                              │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 2.3 이벤트 매트릭스

| 이벤트                  | 발행자                       | 구독자 (리스너)                       | 처리 내용          | 동기/비동기 |
| ----------------------- | ---------------------------- | ------------------------------------- | ------------------ | ----------- |
| `order.processing`      | ProcessPaymentUseCase        | Product: OnOrderProcessingListener    | 재고 확정 차감     | 동기        |
| `order.processing`      | ProcessPaymentUseCase        | Coupon: OnOrderProcessingListener     | 쿠폰 사용 처리     | 동기        |
| `order.payment`         | ProcessPaymentUseCase        | User: OnOrderPaymentListener          | 잔액 차감          | 동기        |
| `order.processed`       | ProcessPaymentUseCase        | Order: OnOrderProcessedListener       | 데이터 플랫폼 전송 | 비동기      |
| `order.processed`       | ProcessPaymentUseCase        | Product: OnOrderProcessedListener     | 판매 랭킹 업데이트 | 비동기      |
| `order.processing.fail` | 각 리스너 (실패 시)          | Product: OnOrderFailListener          | 재고 롤백          | 동기        |
| `order.processing.fail` | 각 리스너 (실패 시)          | Coupon: OnOrderProcessingFailListener | 쿠폰 롤백          | 동기        |
| `order.payment.fail`    | User: OnOrderPaymentListener | Product: OnOrderFailListener          | 재고 롤백          | 동기        |
| `order.payment.fail`    | User: OnOrderPaymentListener | Coupon: OnOrderFailListener           | 쿠폰 롤백          | 동기        |
| `order.payment.fail`    | User: OnOrderPaymentListener | Order: OnOrderFailListener            | 주문 상태 롤백     | 동기        |

### 2.4 구현 코드 (핵심 부분)

```typescript
// ProcessPaymentUseCase - 이벤트 발행만 담당
async processPayment(cmd: ProcessPaymentCommand) {
  // 1단계: 핵심 로직 (동기) - 재고 차감, 쿠폰 사용
  await this.eventEmitter.emitAsync('order.processing', event);

  // 2단계: 핵심 로직 (동기) - 잔액 차감
  await this.eventEmitter.emitAsync('order.payment', event);

  // 3단계: 부가 로직 (비동기) - 데이터 플랫폼 전송, 랭킹 집계
  this.eventEmitter.emit('order.processed', event); // await 없음!

  return ProcessPaymentResult.from(order, user);
}

// OnOrderProcessedListener - 데이터 플랫폼 전송
@OnEvent('order.processed')
async handle(event: OrderProcessedEvent) {
  try {
    await this.sendToDataPlatform(event);
  } catch (error) {
    // ✅ 실패해도 결제에 영향 없음
    this.logger.error('데이터 플랫폼 전송 실패', error);
  }
}
```

---

## 3. 트랜잭션 분리 전략

### 3.1 핵심/부가 작업 분류

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        핵심/부가 작업 분류 기준                               │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ 🔴 핵심 작업 (Core Operations) - 트랜잭션 내부                          │ │
│  │ ─────────────────────────────────────────────────────────────────────── │ │
│  │ • 실패 시 전체 결제가 실패해야 하는 작업                                │ │
│  │ • 데이터 일관성이 반드시 보장되어야 하는 작업                           │ │
│  │ • 강한 일관성을 위해 보상 트랜잭션이 필요한 작업                         │ │
│  │                                                                          │ │
│  │ 예시:                                                                    │ │
│  │  ├── 재고 확정 차감 (order.processing)                                  │ │
│  │  ├── 쿠폰 사용 처리 (order.processing)                                  │ │
│  │  ├── 잔액 차감 (order.payment)                                          │ │
│  │  └── 주문 상태 변경                                                     │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ 🟢 부가 작업 (Side Effects) - 트랜잭션 외부                             │ │
│  │ ─────────────────────────────────────────────────────────────────────── │ │
│  │ • 실패해도 핵심 기능에 영향을 주면 안 되는 작업                         │ │
│  │ • 최종 일관성(Eventual Consistency)이 허용되는 작업                     │ │
│  │ • 외부 시스템 연동 작업                                                 │ │
│  │                                                                          │ │
│  │ 예시:                                                                    │ │
│  │  ├── 데이터 플랫폼 전송 (order.processed)                               │ │
│  │  ├── 인기상품 랭킹 업데이트 (order.processed)                           │ │
│  │  ├── 알림 발송                                                          │ │
│  │  └── 로깅/모니터링                                                      │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 동기/비동기 이벤트 선택 기준

| 기준          | 동기 이벤트 (emitAsync)         | 비동기 이벤트 (emit)                |
| ------------- | ------------------------------- | ----------------------------------- |
| **실패 처리** | 예외 전파, 트랜잭션 롤백        | 로깅 후 별도 처리                   |
| **응답 대기** | 처리 완료까지 대기              | Fire & Forget                       |
| **사용 예시** | 재고 차감, 쿠폰 사용, 잔액 차감 | 데이터 플랫폼 전송, 랭킹 집계       |
| **처리 보장** | 즉시 처리 및 결과 확인          | 처리 결과 비보장 (별도 재시도 필요) |

### 3.3 트랜잭션 분리에 따른 문제점과 해결 전략

트랜잭션을 분리하면 데이터 일관성 문제가 발생할 수 있습니다. 이에 대한 문제점과 해결 방안을 정리합니다.

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     트랜잭션 분리 시 발생 가능한 문제점                        │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ 🔴 문제 1: 부분 실패로 인한 데이터 불일치                               │ │
│  │ ─────────────────────────────────────────────────────────────────────── │ │
│  │                                                                          │ │
│  │ 시나리오: 재고 차감 ✅ → 쿠폰 사용 ✅ → 잔액 차감 ❌ (잔액 부족)        │ │
│  │                                                                          │ │
│  │ 발생 문제:                                                               │ │
│  │ • 재고는 차감되었으나 결제 실패                                         │ │
│  │ • 쿠폰은 사용되었으나 실제 구매 안됨                                    │ │
│  │ • 데이터 불일치 상태 발생                                               │ │
│  │                                                                          │ │
│  │ ✅ 해결: Saga 패턴 기반 보상 트랜잭션                                   │ │
│  │ • order.payment.fail 이벤트 발행                                        │ │
│  │ • Product 리스너: 재고 롤백 (자체 트랜잭션)                             │ │
│  │ • Coupon 리스너: 쿠폰 사용 취소 (자체 트랜잭션)                         │ │
│  │ • Order 리스너: 주문 상태 롤백 (자체 트랜잭션)                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ 🔴 문제 2: 보상 트랜잭션 실패 시 복구 불가                              │ │
│  │ ─────────────────────────────────────────────────────────────────────── │ │
│  │                                                                          │ │
│  │ 시나리오: 잔액 차감 실패 → 재고 롤백 시도 → 롤백도 실패 ❌             │ │
│  │                                                                          │ │
│  │ 발생 문제:                                                               │ │
│  │ • 재고가 차감된 상태로 남음                                             │ │
│  │ • 자동 복구 불가능한 상태                                               │ │
│  │                                                                          │ │
│  │ ✅ 해결: 로깅 + 수동 복구 + 재시도 메커니즘                             │ │
│  │ • 보상 실패 시 상세 로그 기록                                           │ │
│  │ • 알림 발송 (운영팀 수동 개입)                                          │ │
│  │ • 향후: Dead Letter Queue + 재시도 구현                                 │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ 🔴 문제 3: 이벤트 유실                                                  │ │
│  │ ─────────────────────────────────────────────────────────────────────── │ │
│  │                                                                          │ │
│  │ 시나리오: order.processed 이벤트 발행 후 애플리케이션 크래시            │ │
│  │                                                                          │ │
│  │ 발생 문제:                                                               │ │
│  │ • 데이터 플랫폼에 주문 정보 미전송                                      │ │
│  │ • 인기상품 랭킹 집계 누락                                               │ │
│  │                                                                          │ │
│  │ ✅ 현재 해결: 부가 로직으로 분류하여 핵심 로직에 영향 없음              │ │
│  │ ✅ 향후 해결: Outbox 패턴 + Message Broker 도입                         │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ 🔴 문제 4: 리스너 실행 순서 보장 불가                                   │ │
│  │ ─────────────────────────────────────────────────────────────────────── │ │
│  │                                                                          │ │
│  │ 시나리오: order.processing 이벤트에 Product, Coupon 리스너가 동시 실행  │ │
│  │                                                                          │ │
│  │ 발생 문제:                                                               │ │
│  │ • 리스너 실행 순서가 보장되지 않음                                      │ │
│  │ • 의존 관계가 있는 작업 시 문제 발생 가능                               │ │
│  │                                                                          │ │
│  │ ✅ 해결: 리스너 간 의존성 제거                                          │ │
│  │ • 각 리스너는 독립적으로 실행 가능하도록 설계                           │ │
│  │ • 순서가 필요한 경우 이벤트를 단계별로 분리                             │ │
│  │   (order.processing → order.payment → order.processed)                  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 3.4 트랜잭션 범위 비교

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                          트랜잭션 구조 비교                                   │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                               │
│  [AS-IS: 분리된 트랜잭션 + UseCase 직접 의존]                                │
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ ProcessPaymentUseCase                                                    │ │
│  │ ├── productService.confirmStock()  ──┐                                  │ │
│  │ ├── couponService.useCoupon()    ────┼── Transaction 1                  │ │
│  │ │                                    │                                  │ │
│  │ ├── userService.deductBalance() ─────┴── Transaction 2                  │ │
│  │ │                                                                        │ │
│  │ └── catch { 커밋 상태 체크 후 개별 롤백 }  ◄── 보상 로직 집중 😰        │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│  ⚠️ 문제: UseCase가 모든 서비스에 직접 의존, 보상 로직 복잡                  │
│                                                                               │
│  [TO-BE: 완전 분리된 개별 트랜잭션 + 이벤트 기반]                            │
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ ProcessPaymentUseCase                                                    │ │
│  │ └── eventEmitter.emit() 만 호출  ◄── 오직 이벤트 발행만! 😊             │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                              │                                               │
│          ┌───────────────────┼───────────────────┐                          │
│          ▼                   ▼                   ▼                          │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐               │
│  │ Product Module  │ │ Coupon Module   │ │  User Module    │               │
│  │ ─────────────── │ │ ─────────────── │ │ ─────────────── │               │
│  │ Transaction A   │ │ Transaction B   │ │ Transaction C   │               │
│  │ 재고 확정 차감  │ │ 쿠폰 사용 처리   │ │ 잔액 차감        │               │
│  │ 실패→자체 롤백  │ │ 실패→자체 롤백   │ │ 실패→자체 롤백   │               │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘               │
│                                                                               │
│  ✅ 각 도메인이 자신의 트랜잭션과 보상 로직을 독립적으로 관리                │
│  ✅ UseCase는 도메인 서비스에 전혀 의존하지 않음 (100% 결합도 제거)          │
│                                                                               │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## 4. 배포 단위 도메인 분리

### 4.1 도메인별 모듈 구조

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      배포 단위 도메인 분리 구조                               │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                               │
│  각 도메인은 독립된 모듈로 분리되어 있으며, 향후 MSA 전환 시                 │
│  개별 서비스로 분리 가능한 구조입니다.                                       │
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ 📦 ORDER 도메인 (src/order/)                                            │ │
│  │ ─────────────────────────────────────────────────────────────────────── │ │
│  │ 책임: 주문 생성, 주문 상태 관리, 결제 오케스트레이션                     │ │
│  │                                                                          │ │
│  │ ├── order.module.ts              # 모듈 정의                            │ │
│  │ ├── application/                                                        │ │
│  │ │   ├── create-order.use-case.ts                                       │ │
│  │ │   ├── process-payment.use-case.ts   # 이벤트 발행 (오케스트레이터)   │ │
│  │ │   ├── events/                       # 도메인 이벤트 정의              │ │
│  │ │   │   ├── order-processing.event.ts                                  │ │
│  │ │   │   ├── order-payment.event.ts                                     │ │
│  │ │   │   └── order-processed.event.ts                                   │ │
│  │ │   └── listeners/                    # 이벤트 구독자                   │ │
│  │ │       ├── on-order-processed.listener.ts  # 데이터 플랫폼 전송       │ │
│  │ │       └── on-order-fail.listener.ts       # 주문 상태 롤백           │ │
│  │ ├── domain/                                                             │ │
│  │ └── infrastructure/                                                     │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ 📦 PRODUCT 도메인 (src/product/)                                        │ │
│  │ ─────────────────────────────────────────────────────────────────────── │ │
│  │ 책임: 상품 관리, 재고 관리, 판매 랭킹 집계                              │ │
│  │                                                                          │ │
│  │ ├── product.module.ts                                                   │ │
│  │ ├── application/                                                        │ │
│  │ │   ├── get-products.use-case.ts                                       │ │
│  │ │   └── listeners/                                                      │ │
│  │ │       ├── on-order-processing.listener.ts  # 재고 확정 차감          │ │
│  │ │       ├── on-order-processed.listener.ts   # 판매 랭킹 집계          │ │
│  │ │       └── on-order-fail.listener.ts        # 재고 롤백               │ │
│  │ ├── domain/                                                             │ │
│  │ └── infrastructure/                                                     │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ 🏷️ COUPON 도메인 (src/coupon/)                                          │ │
│  │ ─────────────────────────────────────────────────────────────────────── │ │
│  │ 책임: 쿠폰 발급, 쿠폰 사용/취소 처리                                    │ │
│  │                                                                          │ │
│  │ ├── coupon.module.ts                                                    │ │
│  │ ├── application/                                                        │ │
│  │ │   ├── issue-coupon.use-case.ts                                       │ │
│  │ │   └── listeners/                                                      │ │
│  │ │       ├── on-order-processing.listener.ts  # 쿠폰 사용 처리          │ │
│  │ │       └── on-order-fail.listener.ts        # 쿠폰 사용 취소          │ │
│  │ ├── domain/                                                             │ │
│  │ └── infrastructure/                                                     │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ 👤 USER 도메인 (src/user/)                                              │ │
│  │ ─────────────────────────────────────────────────────────────────────── │ │
│  │ 책임: 사용자 관리, 잔액 충전/차감                                       │ │
│  │                                                                          │ │
│  │ ├── user.module.ts                                                      │ │
│  │ ├── application/                                                        │ │
│  │ │   ├── charge-balance.use-case.ts                                     │ │
│  │ │   └── listeners/                                                      │ │
│  │ │       └── on-order-payment.listener.ts     # 잔액 차감               │ │
│  │ ├── domain/                                                             │ │
│  │ └── infrastructure/                                                     │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ 🛒 CART 도메인 (src/cart/)                                              │ │
│  │ ─────────────────────────────────────────────────────────────────────── │ │
│  │ 책임: 장바구니 관리                                                     │ │
│  │                                                                          │ │
│  │ ├── cart.module.ts                                                      │ │
│  │ ├── application/                                                        │ │
│  │ ├── domain/                                                             │ │
│  │ └── infrastructure/                                                     │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 도메인 간 통신 방식

| 통신 유형              | 방식                      | 사용 사례                            |
| ---------------------- | ------------------------- | ------------------------------------ |
| **도메인 내부**        | 직접 호출 (DomainService) | 주문 생성 시 OrderDomainService 호출 |
| **도메인 간 (동기)**   | 이벤트 (emitAsync)        | 결제 시 재고/쿠폰/잔액 처리          |
| **도메인 간 (비동기)** | 이벤트 (emit)             | 데이터 플랫폼 전송, 랭킹 집계        |

### 4.3 도메인별 이벤트 리스너

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        도메인별 이벤트 리스너 구조                            │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ 📦 ORDER 도메인                                                         │ │
│  │ ─────────────────────────────────────────────────────────────────────── │ │
│  │ • OnOrderProcessedListener: 데이터 플랫폼 전송                          │ │
│  │ • OnOrderFailListener: 주문 상태 롤백 (PAID → PENDING)                  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ 📦 PRODUCT 도메인                                                       │ │
│  │ ─────────────────────────────────────────────────────────────────────── │ │
│  │ • OnOrderProcessingListener: 재고 확정 차감                             │ │
│  │ • OnOrderProcessedListener: 판매 랭킹 업데이트 (Redis)                  │ │
│  │ • OnOrderFailListener: 재고 롤백 (확정 → 선점)                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ 🏷️ COUPON 도메인                                                        │ │
│  │ ─────────────────────────────────────────────────────────────────────── │ │
│  │ • OnOrderProcessingListener: 쿠폰 사용 처리 (Redis → DB 동기화)         │ │
│  │ • OnOrderFailListener: 쿠폰 사용 취소 (Redis 롤백)                      │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ 👤 USER 도메인                                                          │ │
│  │ ─────────────────────────────────────────────────────────────────────── │ │
│  │ • OnOrderPaymentListener: 잔액 차감 (낙관적 잠금 + 재시도)              │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 4.4 관심사 분리 효과

| 항목               | AS-IS                                            | TO-BE                                        |
| ------------------ | ------------------------------------------------ | -------------------------------------------- |
| **의존성 방향**    | UseCase → Product, Coupon, User 서비스 직접 의존 | UseCase → EventEmitter만 의존 (100% 분리)    |
| **트랜잭션 관리**  | UseCase의 catch에서 커밋 상태 체크 후 롤백       | 각 리스너가 자체 트랜잭션 + 실패 이벤트 발행 |
| **보상 트랜잭션**  | UseCase에 롤백 로직 집중                         | 각 도메인이 자체 롤백 리스너 보유            |
| **코드 변경 영향** | 하나의 변경이 UseCase에 영향                     | 해당 리스너만 변경                           |
| **테스트 용이성**  | 모든 의존성 Mock 필요                            | 이벤트 발행/수신만 테스트                    |
| **확장성**         | 새 기능 추가 시 UseCase 수정                     | 새 리스너 추가만으로 확장                    |

---

## 5. 핵심 로직과 부가 로직 분리

### 5.1 핵심 로직 vs 부가 로직 분류

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      핵심 로직 vs 부가 로직 분류                              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ 🔴 핵심 로직 (Core Business Logic)                                      │ │
│  │ ─────────────────────────────────────────────────────────────────────── │ │
│  │ • 실패 시 전체 비즈니스가 실패해야 함                                   │ │
│  │ • 즉각적인 데이터 일관성 필수                                           │ │
│  │ • 동기 이벤트 (emitAsync)로 처리                                        │ │
│  │                                                                          │ │
│  │ 구현:                                                                    │ │
│  │ ├── 재고 확정 차감 (order.processing → Product 리스너)                  │ │
│  │ ├── 쿠폰 사용 처리 (order.processing → Coupon 리스너)                   │ │
│  │ └── 잔액 차감 (order.payment → User 리스너)                             │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ 🟢 부가 로직 (Side Effects)                                             │ │
│  │ ─────────────────────────────────────────────────────────────────────── │ │
│  │ • 실패해도 핵심 비즈니스에 영향 없음                                    │ │
│  │ • 최종 일관성 허용 (나중에 처리해도 됨)                                 │ │
│  │ • 비동기 이벤트 (emit)로 처리 - Fire & Forget                           │ │
│  │                                                                          │ │
│  │ 구현:                                                                    │ │
│  │ ├── 데이터 플랫폼 전송 (order.processed → Order 리스너)                 │ │
│  │ └── 인기상품 랭킹 집계 (order.processed → Product 리스너)               │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 5.2 데이터 플랫폼 전송 - 핵심 로직에 영향 없는 구현

```
┌──────────────────────────────────────────────────────────────────────────────┐
│           데이터 플랫폼 전송이 핵심 로직에 영향을 주지 않는 구조              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ ProcessPaymentUseCase                                                    │ │
│  │                                                                          │ │
│  │   // 1단계: 핵심 로직 (동기 - 실패 시 롤백)                             │ │
│  │   await this.eventEmitter.emitAsync('order.processing', event);         │ │
│  │   // → 재고 차감, 쿠폰 사용                                             │ │
│  │   // → 실패 시 Exception 전파 → 결제 실패                               │ │
│  │                                                                          │ │
│  │   // 2단계: 핵심 로직 (동기 - 실패 시 롤백)                             │ │
│  │   await this.eventEmitter.emitAsync('order.payment', event);            │ │
│  │   // → 잔액 차감                                                        │ │
│  │   // → 실패 시 Exception 전파 → 보상 트랜잭션 실행                      │ │
│  │                                                                          │ │
│  │   // 3단계: 부가 로직 (비동기 - Fire & Forget)                          │ │
│  │   this.eventEmitter.emit('order.processed', event);  ◄── await 없음!   │ │
│  │   // → 데이터 플랫폼 전송, 랭킹 집계                                    │ │
│  │   // → 실패해도 결제는 이미 성공 상태                                   │ │
│  │                                                                          │ │
│  │   return ProcessPaymentResult.from(order, user);  // 바로 응답 반환     │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ OnOrderProcessedListener (데이터 플랫폼 전송)                           │ │
│  │                                                                          │ │
│  │   @OnEvent('order.processed')                                           │ │
│  │   async handle(event: OrderProcessedEvent) {                            │ │
│  │     try {                                                                │ │
│  │       // 외부 데이터 플랫폼으로 주문 정보 전송                          │ │
│  │       await this.sendToDataPlatform(event);                             │ │
│  │       this.logger.log('데이터 플랫폼 전송 완료');                        │ │
│  │     } catch (error) {                                                    │ │
│  │       // ✅ 핵심 포인트: 실패해도 결제에 영향 없음                      │ │
│  │       this.logger.error('데이터 플랫폼 전송 실패', error);               │ │
│  │       // 재시도 큐 등록 또는 알림 발송                                  │ │
│  │     }                                                                    │ │
│  │   }                                                                      │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
│  ✅ 핵심: emit() 사용 (비동기) - await 없이 이벤트 발행                      │
│  ✅ 효과: 데이터 플랫폼 장애/지연이 결제 응답 시간에 영향 없음              │
│  ✅ 효과: 데이터 플랫폼 전송 실패해도 결제는 성공 처리됨                    │
│                                                                               │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 5.3 장애 격리 시나리오

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                   외부 API(데이터 플랫폼) 장애 시 동작                        │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                               │
│  [데이터 플랫폼 API 장애 발생! 🔴]                                           │
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ ProcessPaymentUseCase 실행                                               │ │
│  │                                                                          │ │
│  │  1. order.processing 이벤트 (동기)                                      │ │
│  │     └── 재고 차감 ✅, 쿠폰 사용 ✅                                      │ │
│  │                                                                          │ │
│  │  2. order.payment 이벤트 (동기)                                         │ │
│  │     └── 잔액 차감 ✅                                                    │ │
│  │                                                                          │ │
│  │  3. order.processed 이벤트 (비동기 - Fire & Forget)                     │ │
│  │     ├── 데이터 플랫폼 전송 ❌ (장애 발생)                               │ │
│  │     │   └── 에러 로깅, 재시도 큐 등록 (별도 처리)                       │ │
│  │     └── 판매 랭킹 집계 ✅                                               │ │
│  │                                                                          │ │
│  │  4. 결제 응답 반환 ✅                                                   │ │
│  │     └── 사용자에게 결제 성공 응답                                       │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
│  ✅ 결과: 결제 성공! 데이터 플랫폼 전송은 나중에 재시도                      │
│  ✅ 사용자 경험: 장애 상황에서도 정상적인 결제 처리                          │
│                                                                               │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 5.4 핵심 로직 실패 시 보상 트랜잭션

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      보상 트랜잭션 흐름 (Saga Pattern)                        │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                               │
│  [잔액 부족으로 order.payment 실패 시]                                       │
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ 1. order.processing 성공                                                │ │
│  │    ├── 재고 확정 차감 ✅                                                │ │
│  │    └── 쿠폰 사용 처리 ✅                                                │ │
│  │                                                                          │ │
│  │ 2. order.payment 실패 ❌ (잔액 부족)                                    │ │
│  │    └── order.payment.fail 이벤트 발행                                   │ │
│  │                                                                          │ │
│  │ 3. 보상 트랜잭션 실행                                                   │ │
│  │    ├── Product: 재고 롤백 (확정 → 선점)                                 │ │
│  │    ├── Coupon: 쿠폰 사용 취소 (Redis + DB)                              │ │
│  │    └── Order: 주문 상태 롤백 (PAID → PENDING)                           │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
│  [구현 코드]                                                                 │
│                                                                               │
│  // User: OnOrderPaymentListener                                             │
│  @OnEvent(OrderPaymentEvent.EVENT_NAME)                                      │
│  async handleUserBalanceDeductByOrder(event) {                               │
│    try {                                                                     │
│      await this.userService.deductBalance(userId, amount);                   │
│      return { listenerName: 'UserBalanceDeductByOrder', user };              │
│    } catch (error) {                                                         │
│      // 보상 트랜잭션 트리거                                                 │
│      await this.eventEmitter.emitAsync(                                      │
│        OrderPaymentFailEvent.EVENT_NAME,                                     │
│        new OrderPaymentFailEvent(...),                                       │
│      );                                                                      │
│      return { listenerName: 'UserBalanceDeductByOrder', error };             │
│    }                                                                         │
│  }                                                                           │
│                                                                               │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 5.5 동시성 제어 전략

| 리소스         | 동시성 제어 방식            | 목적                     |
| -------------- | --------------------------- | ------------------------ |
| 주문 결제      | Redis 분산락 (TTL 10s)      | 동일 주문 중복 결제 방지 |
| 상품 재고      | DB 비관적 잠금 (FOR UPDATE) | 재고 초과 판매 방지      |
| 사용자 잔액    | DB 낙관적 잠금 + 재시도     | 동시 잔액 변경 충돌 해결 |
| 쿠폰 발급/사용 | Redis Lua 스크립트          | 원자적 처리로 중복 방지  |

---

## 6. 결론

### 6.1 이벤트 기반 설계로 확보된 것들

```
1. 느슨한 결합 (Loose Coupling)
   • 도메인 간 직접 의존성 제거
   • 이벤트를 통한 간접 통신

2. 관심사 분리 (Separation of Concerns)
   • 각 도메인이 자신의 이벤트 리스너만 관리
   • 비즈니스 로직이 도메인 내부에 캡슐화

3. Saga 패턴 기반 트랜잭션
   • 보상 트랜잭션으로 분산 트랜잭션 대체 가능
   • 최종 일관성(Eventual Consistency) 허용
```

### 6.2 적용 결과 요약

| 항목              | AS-IS                              | TO-BE                          | 개선 효과            |
| ----------------- | ---------------------------------- | ------------------------------ | -------------------- |
| **도메인 결합도** | UseCase → 4개 서비스 직접 의존     | UseCase → EventEmitter만 의존  | **100% 결합도 제거** |
| **트랜잭션 관리** | UseCase의 catch에서 커밋 상태 체크 | 각 도메인이 자체 트랜잭션 관리 | 책임 분산            |
| **보상 트랜잭션** | UseCase에 롤백 로직 집중           | 각 도메인이 자체 롤백 리스너   | 복잡도 분산          |
| **확장성**        | UseCase 수정 필요                  | 리스너 추가만                  | 무중단 기능 추가     |
| **테스트 용이성** | 모든 의존성 Mock                   | 이벤트만 테스트                | 테스트 코드 간소화   |
| **MSA 전환 준비** | 서비스 분리 시 대규모 리팩토링     | 이벤트 버스만 교체             | 전환 비용 최소화     |

### 6.3 이벤트 기반 아키텍처의 장점 리뷰

```

┌──────────────────────────────────────────────────────────────────────────────┐
│ 이벤트 기반 완전 분리 아키텍처 장점 요약                                        │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                               │
│ 1️⃣ 100% 결합도 제거 (Zero Coupling)                                          │
│ • UseCase는 오직 EventEmitter와 자신의 도메인 서비스만 의존                     │
│ • Product, Coupon, User 서비스에 대한 직접 의존성 완전 제거                     │
│ • MSA 전환 시 서비스 분리가 자연스럽게 가능                                     │
│                                                                               │
│ 2️⃣ 자율적 트랜잭션 관리                                                        │
│ • 각 도메인이 자신의 트랜잭션을 독립적으로 관리                                 │
│ • 재고/쿠폰/잔액 처리가 개별 트랜잭션으로 분리                                  │
│ • 트랜잭션 충돌 및 락 경합 최소화                                              │
│                                                                               │
│ 3️⃣ 분산 보상 트랜잭션 (Saga Pattern)                                          │
│ • UseCase는 롤백 로직 없음 (복잡도 제거)                                       │
│ • 각 도메인이 자체 OnOrderFailListener로 롤백 처리                             │
│ • 실패 이벤트 발행 → 관련 도메인들이 자율적으로 보상 수행                       │
│                                                                              │
│ 4️⃣ 완전한 관심사 분리                                                        │
│ • Order: 주문 상태 관리, 데이터 플랫폼 전송                                   │
│ • Product: 재고 관리, 판매 랭킹 집계                                         │
│ • Coupon: 쿠폰 사용/취소 처리                                                │
│ • User: 잔액 차감/환불 처리                                                  │
│                                                                             │
│ 5️⃣ 무한 확장성                                                              │
│ • 새로운 기능 추가 시 리스너만 등록 (UseCase 수정 불필요)                      │
│ • 알림, 분석, 로깅 등 부가 기능 자유롭게 추가                                 │
│ • 기존 코드 영향 없이 기능 확장 가능                                          │
│                                                                             │
└──────────────────────────────────────────────────────────────────────────────┘

```

---

> 📅 문서 작성일: 2025년 12월 9일
